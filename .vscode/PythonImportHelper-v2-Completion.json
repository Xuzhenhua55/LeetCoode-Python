[
    {
        "label": "sleep",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二分法.34.在排序数组中查找元素的第一个和最后一个位置",
        "description": "二分法.34.在排序数组中查找元素的第一个和最后一个位置",
        "peekOfCode": "class Solution(object):\n    # 最后一个小于target的数\n    def findLeft(self,nums,target):\n        left,right=0,len(nums)\n        while(left<right):\n            mid=left+(right-left)/2\n            if nums[mid]==target or nums[mid]>target:\n                right=mid\n            else:\n                left=mid+1",
        "detail": "二分法.34.在排序数组中查找元素的第一个和最后一个位置",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二分法.35.搜索插入位置",
        "description": "二分法.35.搜索插入位置",
        "peekOfCode": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        left, right = 0, len(nums)\n        while left < right:\n            mid = left + (right - left) / 2",
        "detail": "二分法.35.搜索插入位置",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二分法.367.有效的完全平方数",
        "description": "二分法.367.有效的完全平方数",
        "peekOfCode": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        left,right=0,num+1\n        while left<right:\n            mid=left+(right-left)/2\n            if mid*mid <= num:",
        "detail": "二分法.367.有效的完全平方数",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二分法.69.x的平方根",
        "description": "二分法.69.x的平方根",
        "peekOfCode": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        left,right=0,x+1\n        while left<right:\n            mid=left+(right-left)/2\n            if mid*mid<x or mid*mid ==x:",
        "detail": "二分法.69.x的平方根",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二分法.704.二分查找",
        "description": "二分法.704.二分查找",
        "peekOfCode": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        left=0,right=len(nums-1)\n        while(left<=right):\n            mid=left+(right-left)/2",
        "detail": "二分法.704.二分查找",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二分法.704.二分查找",
        "description": "二分法.704.二分查找",
        "peekOfCode": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        left,right=0,len(nums)\n        while(left<right):\n            mid=left+(right-left)/2",
        "detail": "二分法.704.二分查找",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二分法.977.有序数组的平方",
        "description": "二分法.977.有序数组的平方",
        "peekOfCode": "class Solution(object):\n    def sortedSquares(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result=[]\n        left,right=0,len(nums)-1\n        while left<=right:\n            if abs(nums[left])<abs(nums[right]):",
        "detail": "二分法.977.有序数组的平方",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "二叉树.二叉搜索树.108.将有序数组转换为二叉搜索树",
        "description": "二叉树.二叉搜索树.108.将有序数组转换为二叉搜索树",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: Optional[TreeNode]",
        "detail": "二叉树.二叉搜索树.108.将有序数组转换为二叉搜索树",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二叉树.二叉搜索树.108.将有序数组转换为二叉搜索树",
        "description": "二叉树.二叉搜索树.108.将有序数组转换为二叉搜索树",
        "peekOfCode": "class Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        def createNode(nums, left, right):\n            if left > right: return None\n            midIndex = left + (right - left) / 2\n            curNode = TreeNode(nums[midIndex])",
        "detail": "二叉树.二叉搜索树.108.将有序数组转换为二叉搜索树",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二叉树.二叉搜索树.235.二叉搜索树的最近公共祖先",
        "description": "二叉树.二叉搜索树.235.二叉搜索树的最近公共祖先",
        "peekOfCode": "class Solution(object):\n    def lowestCommonAncestor(self, root, p, q):\n        \"\"\"\n        :type root: TreeNode\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        if not root: return None\n        if root and root==p or root==q:",
        "detail": "二叉树.二叉搜索树.235.二叉搜索树的最近公共祖先",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二叉树.二叉搜索树.450.删除二叉搜索树中的节点",
        "description": "二叉树.二叉搜索树.450.删除二叉搜索树中的节点",
        "peekOfCode": "class Solution(object):\n    def deleteNode(self, root, key):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :type key: int\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        if not root: return None\n        if root.val==key:\n            if not root.right: return root.left",
        "detail": "二叉树.二叉搜索树.450.删除二叉搜索树中的节点",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "二叉树.二叉搜索树.501.二叉搜索树中的众数",
        "description": "二叉树.二叉搜索树.501.二叉搜索树中的众数",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: List[int]",
        "detail": "二叉树.二叉搜索树.501.二叉搜索树中的众数",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二叉树.二叉搜索树.501.二叉搜索树中的众数",
        "description": "二叉树.二叉搜索树.501.二叉搜索树中的众数",
        "peekOfCode": "class Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: List[int]\n        \"\"\"\n        self.preVal=None\n        self.curCount=0\n        self.maxCount=-float('inf')\n        self.resultList=[]",
        "detail": "二叉树.二叉搜索树.501.二叉搜索树中的众数",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "二叉树.二叉搜索树.530.二叉搜索树的最小绝对差",
        "description": "二叉树.二叉搜索树.530.二叉搜索树的最小绝对差",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: int",
        "detail": "二叉树.二叉搜索树.530.二叉搜索树的最小绝对差",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二叉树.二叉搜索树.530.二叉搜索树的最小绝对差",
        "description": "二叉树.二叉搜索树.530.二叉搜索树的最小绝对差",
        "peekOfCode": "class Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: int\n        \"\"\"\n        self.preVal=None\n        self.result=float('inf')\n        def DFS(root):\n            if not root: return",
        "detail": "二叉树.二叉搜索树.530.二叉搜索树的最小绝对差",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二叉树.二叉搜索树.538.把二叉搜索树转换为累加树",
        "description": "二叉树.二叉搜索树.538.把二叉搜索树转换为累加树",
        "peekOfCode": "class Solution(object):\n    def convertBST(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        self.curSum = 0\n        def DFS(root):\n            if root == None: return 0\n            DFS(root.right)",
        "detail": "二叉树.二叉搜索树.538.把二叉搜索树转换为累加树",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "二叉树.二叉搜索树.669.修剪二叉搜索树",
        "description": "二叉树.二叉搜索树.669.修剪二叉搜索树",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution(object):\n    def trimBST(self, root, low, high):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :type low: int",
        "detail": "二叉树.二叉搜索树.669.修剪二叉搜索树",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二叉树.二叉搜索树.669.修剪二叉搜索树",
        "description": "二叉树.二叉搜索树.669.修剪二叉搜索树",
        "peekOfCode": "class Solution(object):\n    def trimBST(self, root, low, high):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :type low: int\n        :type high: int\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        if root == None: return None\n        if root.val > high or root.val < low:",
        "detail": "二叉树.二叉搜索树.669.修剪二叉搜索树",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二叉树.二叉搜索树.700.二叉搜索树中的搜索",
        "description": "二叉树.二叉搜索树.700.二叉搜索树中的搜索",
        "peekOfCode": "class Solution(object):\n    def searchBST(self, root, val):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :type val: int\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        if not root:\n            return None\n        if root.val==val:",
        "detail": "二叉树.二叉搜索树.700.二叉搜索树中的搜索",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "二叉树.二叉搜索树.701.二叉搜索树中的插入操作",
        "description": "二叉树.二叉搜索树.701.二叉搜索树中的插入操作",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution(object):\n    def insertIntoBST(self, root, val):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :type val: int",
        "detail": "二叉树.二叉搜索树.701.二叉搜索树中的插入操作",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二叉树.二叉搜索树.701.二叉搜索树中的插入操作",
        "description": "二叉树.二叉搜索树.701.二叉搜索树中的插入操作",
        "peekOfCode": "class Solution(object):\n    def insertIntoBST(self, root, val):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :type val: int\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        if not root:\n            return TreeNode(val)\n        if val < root.val:",
        "detail": "二叉树.二叉搜索树.701.二叉搜索树中的插入操作",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "二叉树.二叉搜索树.98.验证二叉搜索树",
        "description": "二叉树.二叉搜索树.98.验证二叉搜索树",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        def dfs(node):\n            if not node:\n                return True, float(\"inf\"), float(\"-inf\")",
        "detail": "二叉树.二叉搜索树.98.验证二叉搜索树",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二叉树.二叉搜索树.98.验证二叉搜索树",
        "description": "二叉树.二叉搜索树.98.验证二叉搜索树",
        "peekOfCode": "class Solution(object):\n    def isValidBST(self, root):\n        def dfs(node):\n            if not node:\n                return True, float(\"inf\"), float(\"-inf\")\n            leftValid, leftMin, leftMax = dfs(node.left)\n            rightValid, rightMin, rightMax = dfs(node.right)\n            if not leftValid or not rightValid:\n                return False, 0, 0\n            if not (leftMax < node.val < rightMin):",
        "detail": "二叉树.二叉搜索树.98.验证二叉搜索树",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二叉树.二叉搜索树.98.验证二叉搜索树",
        "description": "二叉树.二叉搜索树.98.验证二叉搜索树",
        "peekOfCode": "class Solution(object):\n    def isValidBST(self, root):\n        self.preNode=None\n        def DFS(root):\n            if not root: return True\n            if not DFS(root.left):\n                return False\n            if self.preNode and root.val <= self.preNode.val:\n                return False\n            self.preNode = root",
        "detail": "二叉树.二叉搜索树.98.验证二叉搜索树",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二叉树.二叉搜索树.98.验证二叉搜索树",
        "description": "二叉树.二叉搜索树.98.验证二叉搜索树",
        "peekOfCode": "class Solution(object):\n    def isValidBST(self, root):\n        self.preNode = None\n        self.isValid = True\n        def DFS(root):\n            if not root or not self.isValid:\n                return\n            DFS(root.left)\n            if self.preNode and root.val <= self.preNode.val:\n                self.isValid=False",
        "detail": "二叉树.二叉搜索树.98.验证二叉搜索树",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "二叉树.100.相同的树",
        "description": "二叉树.100.相同的树",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: Optional[TreeNode]\n        :type q: Optional[TreeNode]",
        "detail": "二叉树.100.相同的树",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二叉树.100.相同的树",
        "description": "二叉树.100.相同的树",
        "peekOfCode": "class Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: Optional[TreeNode]\n        :type q: Optional[TreeNode]\n        :rtype: bool\n        \"\"\"\n        if not p and not q:\n            return True\n        if (p and not q) or (q and not p):",
        "detail": "二叉树.100.相同的树",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "二叉树.101.对称二叉树",
        "description": "二叉树.101.对称二叉树",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: bool",
        "detail": "二叉树.101.对称二叉树",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二叉树.101.对称二叉树",
        "description": "二叉树.101.对称二叉树",
        "peekOfCode": "class Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: bool\n        \"\"\"\n        if root==None:\n            return True\n        def isEqual(leftNode,rightNode):\n            if (leftNode and not rightNode) or (rightNode and not leftNode):",
        "detail": "二叉树.101.对称二叉树",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "二叉树.102.二叉树的层序遍历",
        "description": "二叉树.102.二叉树的层序遍历",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: List[List[int]]",
        "detail": "二叉树.102.二叉树的层序遍历",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二叉树.102.二叉树的层序遍历",
        "description": "二叉树.102.二叉树的层序遍历",
        "peekOfCode": "class Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: List[List[int]]\n        \"\"\"\n        from collections import deque\n        deque=deque()\n        resultList=[]\n        if root!=None: deque.append(root)",
        "detail": "二叉树.102.二叉树的层序遍历",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "二叉树.104.二叉树的最大深度",
        "description": "二叉树.104.二叉树的最大深度",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: int",
        "detail": "二叉树.104.二叉树的最大深度",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二叉树.104.二叉树的最大深度",
        "description": "二叉树.104.二叉树的最大深度",
        "peekOfCode": "class Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: int\n        \"\"\"\n        if root==None:\n            return 0\n        def getHeight(root):\n            if root.left==None and root.right==None:",
        "detail": "二叉树.104.二叉树的最大深度",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "二叉树.106.从中序与后序遍历序列构造二叉树",
        "description": "二叉树.106.从中序与后序遍历序列构造二叉树",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]",
        "detail": "二叉树.106.从中序与后序遍历序列构造二叉树",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二叉树.106.从中序与后序遍历序列构造二叉树",
        "description": "二叉树.106.从中序与后序遍历序列构造二叉树",
        "peekOfCode": "class Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        def buildTree(inorder,postorder,inLeft,inRight,postLeft,postRight):\n            if inLeft>inRight or postLeft>postRight:\n                return None",
        "detail": "二叉树.106.从中序与后序遍历序列构造二叉树",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "二叉树.107.二叉树的层序遍历II",
        "description": "二叉树.107.二叉树的层序遍历II",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: List[List[int]]",
        "detail": "二叉树.107.二叉树的层序遍历II",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二叉树.107.二叉树的层序遍历II",
        "description": "二叉树.107.二叉树的层序遍历II",
        "peekOfCode": "class Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: List[List[int]]\n        \"\"\"\n        from collections import deque\n        deque = deque()\n        resultList = []\n        if root != None:",
        "detail": "二叉树.107.二叉树的层序遍历II",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "二叉树.110.平衡二叉树",
        "description": "二叉树.110.平衡二叉树",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: bool",
        "detail": "二叉树.110.平衡二叉树",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二叉树.110.平衡二叉树",
        "description": "二叉树.110.平衡二叉树",
        "peekOfCode": "class Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: bool\n        \"\"\"\n        def getHeight(root):\n            if not root: return 0\n            return max(getHeight(root.left),getHeight(root.right))+1\n        if not root or (not root.left and not root.right): return True",
        "detail": "二叉树.110.平衡二叉树",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二叉树.110.平衡二叉树",
        "description": "二叉树.110.平衡二叉树",
        "peekOfCode": "class Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: bool\n        \"\"\"\n        self.isBalanced=True\n        def DFS(root):\n            if not root: return 0\n            if not self.isBalanced:",
        "detail": "二叉树.110.平衡二叉树",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二叉树.111.二叉树的最小深度",
        "description": "二叉树.111.二叉树的最小深度",
        "peekOfCode": "class Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: int\n        \"\"\"\n        if root==None:\n            return 0\n        def getHeight(root):\n            if root.left!=None and root.right!=None:",
        "detail": "二叉树.111.二叉树的最小深度",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二叉树.112.路径总和",
        "description": "二叉树.112.路径总和",
        "peekOfCode": "class Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        self.hasPathSum=False\n        def DFS(root,targetSum,curSum):\n            if self.hasPathSum:",
        "detail": "二叉树.112.路径总和",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "二叉树.116.填充每个节点的下一个右侧节点指针",
        "description": "二叉树.116.填充每个节点的下一个右侧节点指针",
        "peekOfCode": "class Node(object):\n    def __init__(self, val=0, left=None, right=None, next=None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\nclass Solution(object):\n    def connect(self, root):\n        \"\"\"\n        :type root: Node",
        "detail": "二叉树.116.填充每个节点的下一个右侧节点指针",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二叉树.116.填充每个节点的下一个右侧节点指针",
        "description": "二叉树.116.填充每个节点的下一个右侧节点指针",
        "peekOfCode": "class Solution(object):\n    def connect(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: Node\n        \"\"\"\n        from collections import deque\n        deque=deque()\n        if root:deque.append(root)\n        while bool(deque):",
        "detail": "二叉树.116.填充每个节点的下一个右侧节点指针",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "二叉树.117.填充每个节点的下一个右侧节点指针II",
        "description": "二叉树.117.填充每个节点的下一个右侧节点指针II",
        "peekOfCode": "class Node(object):\n    def __init__(self, val=0, left=None, right=None, next=None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n# 核心思想是遍历当前层（因为在上一层的遍历中已经连接好）的过程中将下一层进行连接\nclass Solution(object):\n    def connect(self, root):\n        \"\"\"",
        "detail": "二叉树.117.填充每个节点的下一个右侧节点指针II",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二叉树.117.填充每个节点的下一个右侧节点指针II",
        "description": "二叉树.117.填充每个节点的下一个右侧节点指针II",
        "peekOfCode": "class Solution(object):\n    def connect(self, root):\n        \"\"\"\n        :type root: Node\n        :rtype: Node\n        \"\"\"\n        curNode=root\n        while curNode:\n            preNode=Node()\n            dummyNode=preNode #暂存下一层的起始点",
        "detail": "二叉树.117.填充每个节点的下一个右侧节点指针II",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "二叉树.144.二叉树的前序遍历",
        "description": "二叉树.144.二叉树的前序遍历",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution(object):\n    def DFS(self,root,resultList):\n        if root == None:\n            return root\n        resultList.append(root.val)",
        "detail": "二叉树.144.二叉树的前序遍历",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二叉树.144.二叉树的前序遍历",
        "description": "二叉树.144.二叉树的前序遍历",
        "peekOfCode": "class Solution(object):\n    def DFS(self,root,resultList):\n        if root == None:\n            return root\n        resultList.append(root.val)\n        self.DFS(root.left,resultList)\n        self.DFS(root.right,resultList)\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]",
        "detail": "二叉树.144.二叉树的前序遍历",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "二叉树.145.二叉树的后序遍历",
        "description": "二叉树.145.二叉树的后序遍历",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: List[int]",
        "detail": "二叉树.145.二叉树的后序遍历",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二叉树.145.二叉树的后序遍历",
        "description": "二叉树.145.二叉树的后序遍历",
        "peekOfCode": "class Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: List[int]\n        \"\"\"\n        resultList=[]\n        def DFS(root):\n            if root==None:\n                return root",
        "detail": "二叉树.145.二叉树的后序遍历",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "二叉树.199.二叉树的右视图",
        "description": "二叉树.199.二叉树的右视图",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution(object):\n    def rightSideView(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: List[int]",
        "detail": "二叉树.199.二叉树的右视图",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二叉树.199.二叉树的右视图",
        "description": "二叉树.199.二叉树的右视图",
        "peekOfCode": "class Solution(object):\n    def rightSideView(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: List[int]\n        \"\"\"\n        from collections import deque\n        deque=deque()\n        resultList=[]\n        if root!=None: deque.append(root)",
        "detail": "二叉树.199.二叉树的右视图",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "二叉树.222.完全二叉树的节点个数",
        "description": "二叉树.222.完全二叉树的节点个数",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: int",
        "detail": "二叉树.222.完全二叉树的节点个数",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二叉树.222.完全二叉树的节点个数",
        "description": "二叉树.222.完全二叉树的节点个数",
        "peekOfCode": "class Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: int\n        \"\"\"\n        if root==None: return 0\n        leftDepth,rightDepth=0,0\n        left,right=root.left,root.right\n        while left:",
        "detail": "二叉树.222.完全二叉树的节点个数",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "二叉树.226.翻转二叉树",
        "description": "二叉树.226.翻转二叉树",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: Optional[TreeNode]",
        "detail": "二叉树.226.翻转二叉树",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二叉树.226.翻转二叉树",
        "description": "二叉树.226.翻转二叉树",
        "peekOfCode": "class Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        if not root: return None\n        leftNode,rightNode=None,None\n        if root.left: \n            leftNode=self.invertTree(root.left)",
        "detail": "二叉树.226.翻转二叉树",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "二叉树.236.二叉树的最近公共祖先",
        "description": "二叉树.236.二叉树的最近公共祖先",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\nclass Solution(object):\n    def lowestCommonAncestor(self, root, p, q):\n        \"\"\"\n        :type root: TreeNode\n        :type p: TreeNode",
        "detail": "二叉树.236.二叉树的最近公共祖先",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二叉树.236.二叉树的最近公共祖先",
        "description": "二叉树.236.二叉树的最近公共祖先",
        "peekOfCode": "class Solution(object):\n    def lowestCommonAncestor(self, root, p, q):\n        \"\"\"\n        :type root: TreeNode\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        self.result=None\n        def DFS(root,p,q):",
        "detail": "二叉树.236.二叉树的最近公共祖先",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二叉树.236.二叉树的最近公共祖先",
        "description": "二叉树.236.二叉树的最近公共祖先",
        "peekOfCode": "class Solution(object):\n    def lowestCommonAncestor(self, root, p, q):\n        \"\"\"\n        :type root: TreeNode\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        if not root: return None\n        if root==p or root==q:",
        "detail": "二叉树.236.二叉树的最近公共祖先",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "二叉树.257.二叉树的所有路径",
        "description": "二叉树.257.二叉树的所有路径",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: List[str]",
        "detail": "二叉树.257.二叉树的所有路径",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二叉树.257.二叉树的所有路径",
        "description": "二叉树.257.二叉树的所有路径",
        "peekOfCode": "class Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: List[str]\n        \"\"\"\n        self.resultList=[]\n        def DFS(root,curPath):\n            curPath.append(str(root.val))\n            if not root.left and not root.right:",
        "detail": "二叉树.257.二叉树的所有路径",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "二叉树.404.左叶子之和",
        "description": "二叉树.404.左叶子之和",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: int",
        "detail": "二叉树.404.左叶子之和",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二叉树.404.左叶子之和",
        "description": "二叉树.404.左叶子之和",
        "peekOfCode": "class Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: int\n        \"\"\"\n        self.resultVal=0\n        def DFS(root,direction):\n            if not root.left and not root.right and direction=='left':\n                self.resultVal += root.val",
        "detail": "二叉树.404.左叶子之和",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "二叉树.513.找树左下角的值",
        "description": "二叉树.513.找树左下角的值",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution(object):\n    def findBottomLeftValue(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: int",
        "detail": "二叉树.513.找树左下角的值",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二叉树.513.找树左下角的值",
        "description": "二叉树.513.找树左下角的值",
        "peekOfCode": "class Solution(object):\n    def findBottomLeftValue(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: int\n        \"\"\"\n        from collections import deque\n        deque=deque()\n        lastNode=root\n        deque.append(lastNode)",
        "detail": "二叉树.513.找树左下角的值",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "二叉树.515.在每个树行中找最大值",
        "description": "二叉树.515.在每个树行中找最大值",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution(object):\n    def largestValues(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: List[int]",
        "detail": "二叉树.515.在每个树行中找最大值",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二叉树.515.在每个树行中找最大值",
        "description": "二叉树.515.在每个树行中找最大值",
        "peekOfCode": "class Solution(object):\n    def largestValues(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: List[int]\n        \"\"\"\n        from collections import deque\n        deque=deque()\n        resultList=[]\n        if root:deque.append(root)",
        "detail": "二叉树.515.在每个树行中找最大值",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "二叉树.572.另一棵树的子树",
        "description": "二叉树.572.另一棵树的子树",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution(object):\n    def isEqual(self,p,q):\n        if (p and not q) or (not p and q): return False\n        if not p and not q: return True\n        return p.val==q.val and self.isEqual(p.left,q.left) and self.isEqual(p.right,q.right)",
        "detail": "二叉树.572.另一棵树的子树",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二叉树.572.另一棵树的子树",
        "description": "二叉树.572.另一棵树的子树",
        "peekOfCode": "class Solution(object):\n    def isEqual(self,p,q):\n        if (p and not q) or (not p and q): return False\n        if not p and not q: return True\n        return p.val==q.val and self.isEqual(p.left,q.left) and self.isEqual(p.right,q.right)\n    def isSubtree(self, root, subRoot):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :type subRoot: Optional[TreeNode]\n        :rtype: bool",
        "detail": "二叉树.572.另一棵树的子树",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "二叉树.617.合并二叉树",
        "description": "二叉树.617.合并二叉树",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution(object):\n    def mergeTrees(self, root1, root2):\n        \"\"\"\n        :type root1: Optional[TreeNode]\n        :type root2: Optional[TreeNode]",
        "detail": "二叉树.617.合并二叉树",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二叉树.617.合并二叉树",
        "description": "二叉树.617.合并二叉树",
        "peekOfCode": "class Solution(object):\n    def mergeTrees(self, root1, root2):\n        \"\"\"\n        :type root1: Optional[TreeNode]\n        :type root2: Optional[TreeNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        if not root1 and not root2:\n            return None\n        if root1 and not root2:",
        "detail": "二叉树.617.合并二叉树",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "二叉树.637.二叉树的层平均值",
        "description": "二叉树.637.二叉树的层平均值",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution(object):\n    def averageOfLevels(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: List[float]",
        "detail": "二叉树.637.二叉树的层平均值",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二叉树.637.二叉树的层平均值",
        "description": "二叉树.637.二叉树的层平均值",
        "peekOfCode": "class Solution(object):\n    def averageOfLevels(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: List[float]\n        \"\"\"\n        from collections import deque\n        deque=deque()\n        resultList=[]\n        if root: deque.append(root)",
        "detail": "二叉树.637.二叉树的层平均值",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "二叉树.654.最大二叉树",
        "description": "二叉树.654.最大二叉树",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution(object):\n    def constructMaximumBinaryTree(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: Optional[TreeNode]",
        "detail": "二叉树.654.最大二叉树",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二叉树.654.最大二叉树",
        "description": "二叉树.654.最大二叉树",
        "peekOfCode": "class Solution(object):\n    def constructMaximumBinaryTree(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        def buildTree(nums,left,right):\n            if left>right:\n                return None\n            maxVal,maxIndex=float(\"-inf\"),-1",
        "detail": "二叉树.654.最大二叉树",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "二叉树.94.二叉树的中序遍历",
        "description": "二叉树.94.二叉树的中序遍历",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: List[int]",
        "detail": "二叉树.94.二叉树的中序遍历",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "二叉树.94.二叉树的中序遍历",
        "description": "二叉树.94.二叉树的中序遍历",
        "peekOfCode": "class Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: List[int]\n        \"\"\"\n        resultList=[]\n        def DFS(root):\n            if root==None:\n                return root",
        "detail": "二叉树.94.二叉树的中序遍历",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "双指针与快慢指针.15.三数之和",
        "description": "双指针与快慢指针.15.三数之和",
        "peekOfCode": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        nums=sorted(nums)\n        resultList=[]\n        for i in range(len(nums)):\n            if nums[i]>0:",
        "detail": "双指针与快慢指针.15.三数之和",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "双指针与快慢指针.151.反转字符串中的单词",
        "description": "双指针与快慢指针.151.反转字符串中的单词",
        "peekOfCode": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        s=' '+s\n        right = len(s)-1\n        resultList=[]\n        while right>0:",
        "detail": "双指针与快慢指针.151.反转字符串中的单词",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "双指针与快慢指针.18.四数之和",
        "description": "双指针与快慢指针.18.四数之和",
        "peekOfCode": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        nums=sorted(nums)\n        resultList=[]\n        for i in range(len(nums)):",
        "detail": "双指针与快慢指针.18.四数之和",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "双指针与快慢指针.26.删除有序数组中的重复项",
        "description": "双指针与快慢指针.26.删除有序数组中的重复项",
        "peekOfCode": "class Solution(object):\n    def afterBackspace(self, input_str):\n        str_list = list(input_str)\n        slow = 0\n        for fast in range(len(str_list)):\n            if str_list[fast] != '#':\n                str_list[slow] = str_list[fast]\n                slow += 1\n            else:\n                slow -= 1",
        "detail": "双指针与快慢指针.26.删除有序数组中的重复项",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "双指针与快慢指针.27.移除元素",
        "description": "双指针与快慢指针.27.移除元素",
        "peekOfCode": "class Solution(object):\n    def removeElement(self, nums, val):\n        \"\"\"\n        :type nums: List[int]\n        :type val: int\n        :rtype: int\n        \"\"\"\n        count=0\n        slow,fast=0,0\n        while fast<len(nums):",
        "detail": "双指针与快慢指针.27.移除元素",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "双指针与快慢指针.28.找出字符串中第一个匹配项的下标",
        "description": "双指针与快慢指针.28.找出字符串中第一个匹配项的下标",
        "peekOfCode": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        resultList=[]\n        for left in range(len(haystack)):\n            if haystack[left]!=needle[0]:",
        "detail": "双指针与快慢指针.28.找出字符串中第一个匹配项的下标",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "双指针与快慢指针.283.移动零",
        "description": "双指针与快慢指针.283.移动零",
        "peekOfCode": "class Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        slow, fast = 0, 0\n        while fast < len(nums):\n            if nums[fast] == 0:\n                fast += 1",
        "detail": "双指针与快慢指针.283.移动零",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "双指针与快慢指针.344.反转字符串",
        "description": "双指针与快慢指针.344.反转字符串",
        "peekOfCode": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        left,right=0,len(s)-1\n        while left<right:\n            s[left],s[right]=s[right],s[left]\n            left+=1",
        "detail": "双指针与快慢指针.344.反转字符串",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "双指针与快慢指针.541.反转字符串II",
        "description": "双指针与快慢指针.541.反转字符串II",
        "peekOfCode": "class Solution(object):\n    def reverseStr(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        s=list(s)\n        left=0\n        while left<len(s):",
        "detail": "双指针与快慢指针.541.反转字符串II",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "双指针与快慢指针.844.比较含退格的字符串",
        "description": "双指针与快慢指针.844.比较含退格的字符串",
        "peekOfCode": "class Solution(object):\n    def afterBackspace(self, input_str):\n        str_list = list(input_str)\n        slow = 0\n        for fast in range(len(str_list)):\n            if str_list[fast] != '#':\n                str_list[slow] = str_list[fast]\n                slow += 1\n            else:\n                slow -= 1",
        "detail": "双指针与快慢指针.844.比较含退格的字符串",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "双指针与快慢指针.977.有序数组的平方",
        "description": "双指针与快慢指针.977.有序数组的平方",
        "peekOfCode": "class Solution(object):\n    def sortedSquares(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        left, right = 0, len(nums)-1\n        while left <= right:\n            if abs(nums[left]) < abs(nums[right]):",
        "detail": "双指针与快慢指针.977.有序数组的平方",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "哈希表.1.两数之和",
        "description": "哈希表.1.两数之和",
        "peekOfCode": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        indexDict=dict()\n        for i in range(len(nums)):\n            if target-nums[i] in indexDict:",
        "detail": "哈希表.1.两数之和",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "哈希表.202.快乐数",
        "description": "哈希表.202.快乐数",
        "peekOfCode": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        usedSet=set()\n        while True:\n            sum=0\n            while n>0:",
        "detail": "哈希表.202.快乐数",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "哈希表.242.有效的字母异位词",
        "description": "哈希表.242.有效的字母异位词",
        "peekOfCode": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        sCountDict=dict()\n        tCountDict=dict()\n        for ch in s:",
        "detail": "哈希表.242.有效的字母异位词",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "哈希表.242.有效的字母异位词",
        "description": "哈希表.242.有效的字母异位词",
        "peekOfCode": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        sCountDict = dict()\n        tCountDict = dict()\n        for ch in s:",
        "detail": "哈希表.242.有效的字母异位词",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "哈希表.349.两个数组的交集",
        "description": "哈希表.349.两个数组的交集",
        "peekOfCode": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        numsSet1,numsSet2=set(),set()\n        for num in nums1:\n            numsSet1.add(num)",
        "detail": "哈希表.349.两个数组的交集",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "哈希表.350.两个数组的交集II",
        "description": "哈希表.350.两个数组的交集II",
        "peekOfCode": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        numsDict1,numsDict2=dict(),dict()\n        for num in nums1:\n            numsDict1[num]=numsDict1.get(num,0)+1",
        "detail": "哈希表.350.两个数组的交集II",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "哈希表.383.赎金信",
        "description": "哈希表.383.赎金信",
        "peekOfCode": "class Solution(object):\n    def canConstruct(self, ransomNote, magazine):\n        \"\"\"\n        :type ransomNote: str\n        :type magazine: str\n        :rtype: bool\n        \"\"\"\n        magazineCountList=[0]*26\n        for ch in magazine:\n            magazineCountList[ord(ch)-ord('a')]+=1",
        "detail": "哈希表.383.赎金信",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "哈希表.454.四数相加II",
        "description": "哈希表.454.四数相加II",
        "peekOfCode": "class Solution(object):\n    def fourSumCount(self, nums1, nums2, nums3, nums4):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type nums3: List[int]\n        :type nums4: List[int]\n        :rtype: int\n        \"\"\"\n        countDict=dict()",
        "detail": "哈希表.454.四数相加II",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "哈希表.49.字母异位词分组",
        "description": "哈希表.49.字母异位词分组",
        "peekOfCode": "class Solution(object):\n    def groupAnagrams(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        from collections import defaultdict\n        usedList=[0]*len(strs)\n        resultList=[]\n        for i in range(len(strs)):",
        "detail": "哈希表.49.字母异位词分组",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "哈希表.49.字母异位词分组",
        "description": "哈希表.49.字母异位词分组",
        "peekOfCode": "class Solution(object):\n    def groupAnagrams(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        str_dict=dict()\n        for str in strs:\n            sortedStr=''.join(sorted(str))\n            if sortedStr not in str_dict:",
        "detail": "哈希表.49.字母异位词分组",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "回溯.131.分割回文串",
        "description": "回溯.131.分割回文串",
        "peekOfCode": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        self.resultList = []\n        self.curList = []\n        def isHuiWen(str):\n            left, right = 0, len(str) - 1",
        "detail": "回溯.131.分割回文串",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "回溯.131.分割回文串",
        "description": "回溯.131.分割回文串",
        "peekOfCode": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        self.resultList = []\n        self.curList = []\n        def isHuiWen(str):\n            left, right = 0, len(str) - 1",
        "detail": "回溯.131.分割回文串",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "回溯.131.分割回文串",
        "description": "回溯.131.分割回文串",
        "peekOfCode": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        self.resultList = []\n        self.curList = []\n        def isHuiWen(str):\n            left, right = 0, len(str) - 1",
        "detail": "回溯.131.分割回文串",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "回溯.17.电话号码的字母组合",
        "description": "回溯.17.电话号码的字母组合",
        "peekOfCode": "class Solution(object):\n    def initNumberDict(self):\n        self.numberDict = {\n            '2': ['a', 'b', 'c'],\n            '3': ['d', 'e', 'f'],\n            '4': ['g', 'h', 'i'],\n            '5': ['j', 'k', 'l'],\n            '6': ['m', 'n', 'o'],\n            '7': ['p', 'q', 'r', 's'],\n            '8': ['t', 'u', 'v'],",
        "detail": "回溯.17.电话号码的字母组合",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "回溯.17.电话号码的字母组合",
        "description": "回溯.17.电话号码的字母组合",
        "peekOfCode": "class Solution(object):\n    def initNumberDict(self):\n        self.numberDict = {\n            '2': ['a', 'b', 'c'],\n            '3': ['d', 'e', 'f'],\n            '4': ['g', 'h', 'i'],\n            '5': ['j', 'k', 'l'],\n            '6': ['m', 'n', 'o'],\n            '7': ['p', 'q', 'r', 's'],\n            '8': ['t', 'u', 'v'],",
        "detail": "回溯.17.电话号码的字母组合",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "回溯.216.组合总和III",
        "description": "回溯.216.组合总和III",
        "peekOfCode": "class Solution(object):\n    def combinationSum3(self, k, n):\n        \"\"\"\n        :type k: int\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        self.resultList = []\n        self.curList = []\n        self.curSum = 0",
        "detail": "回溯.216.组合总和III",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "回溯.332.重新安排行程",
        "description": "回溯.332.重新安排行程",
        "peekOfCode": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        self.graghDict = dict()\n        self.traversedPathDict = dict()\n        for ticket in tickets:\n            if ticket[0] not in self.graghDict:",
        "detail": "回溯.332.重新安排行程",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "回溯.332.重新安排行程",
        "description": "回溯.332.重新安排行程",
        "peekOfCode": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        from collections import defaultdict\n        self.graghDict = defaultdict(list)\n        self.traversedPathDict = defaultdict(int)\n        for ticket in tickets:",
        "detail": "回溯.332.重新安排行程",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "回溯.37.解数独",
        "description": "回溯.37.解数独",
        "peekOfCode": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        def calChunkIndex(row, column):\n            return (row // 3) * 3 + (column // 3)\n        from collections import defaultdict\n        self.rowUnexistedDict = defaultdict(lambda: set(range(1, 10)))",
        "detail": "回溯.37.解数独",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "回溯.37.解数独",
        "description": "回溯.37.解数独",
        "peekOfCode": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        def calChunkIndex(row, column):\n            return (row // 3) * 3 + (column // 3)\n        from collections import defaultdict\n        self.rowUnexistedDict = defaultdict(lambda: set(range(1, 10)))",
        "detail": "回溯.37.解数独",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "回溯.39.组合总和",
        "description": "回溯.39.组合总和",
        "peekOfCode": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        self.curList = []\n        self.curSum = 0\n        self.resultList = []",
        "detail": "回溯.39.组合总和",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "回溯.40.组合总和II",
        "description": "回溯.40.组合总和II",
        "peekOfCode": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        self.curList = []\n        self.curSum = 0\n        self.resultList = []",
        "detail": "回溯.40.组合总和II",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "回溯.46.全排列",
        "description": "回溯.46.全排列",
        "peekOfCode": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        self.curList = []\n        self.resultList = []\n        self.pathSet = set()\n        def DFS():",
        "detail": "回溯.46.全排列",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "回溯.47.全排列II",
        "description": "回溯.47.全排列II",
        "peekOfCode": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        self.curList = []\n        self.resultList = []\n        self.pathExisted = [False] * len(nums)\n        def DFS():",
        "detail": "回溯.47.全排列II",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "回溯.491.非递减子序列",
        "description": "回溯.491.非递减子序列",
        "peekOfCode": "class Solution(object):\n    def findSubsequences(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        self.curList = []\n        self.resultList = []\n        def DFS(start):\n            if len(self.curList) >= 2:",
        "detail": "回溯.491.非递减子序列",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "回溯.51.N皇后",
        "description": "回溯.51.N皇后",
        "peekOfCode": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        self.matrix = [['.' for _ in range(n)] for _ in range(n)]\n        self.resultList = []\n        def isValid(row, column):\n            for i in range(1, n):",
        "detail": "回溯.51.N皇后",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "回溯.77.组合",
        "description": "回溯.77.组合",
        "peekOfCode": "class Solution(object):\n    def combine(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        self.resultList = []\n        self.curList = []\n        def DFS(start, end):",
        "detail": "回溯.77.组合",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "回溯.78.子集",
        "description": "回溯.78.子集",
        "peekOfCode": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        self.curList = []\n        self.resultList = []\n        def DFS(start):\n            self.resultList.append(list(self.curList))",
        "detail": "回溯.78.子集",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "回溯.90.子集II",
        "description": "回溯.90.子集II",
        "peekOfCode": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        self.curList = []\n        self.resultList = []\n        nums.sort()\n        def DFS(start):",
        "detail": "回溯.90.子集II",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "回溯.93.复原IP地址",
        "description": "回溯.93.复原IP地址",
        "peekOfCode": "class Solution(object):\n    def restoreIpAddresses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        self.curList = []\n        self.resultList = []\n        def isValid(str):\n            if str[0] == '0' and len(str) > 1: return False",
        "detail": "回溯.93.复原IP地址",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "基础模拟.54.螺旋矩阵",
        "description": "基础模拟.54.螺旋矩阵",
        "peekOfCode": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        m, n = len(matrix), len(matrix[0])\n        x, y = 0, 0\n        resultList = []\n        while m > 1 and n > 1:",
        "detail": "基础模拟.54.螺旋矩阵",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "基础模拟.54.螺旋矩阵",
        "description": "基础模拟.54.螺旋矩阵",
        "peekOfCode": "s = Solution()\ns.spiralOrder([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])",
        "detail": "基础模拟.54.螺旋矩阵",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "基础模拟.59.螺旋矩阵II",
        "description": "基础模拟.59.螺旋矩阵II",
        "peekOfCode": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        resultMatrix = [[0]*n for _ in range(n)]\n        x, y = 0, 0\n        num = 1\n        maxValue, length = n*n, n",
        "detail": "基础模拟.59.螺旋矩阵II",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "基础模拟.59.螺旋矩阵II",
        "description": "基础模拟.59.螺旋矩阵II",
        "peekOfCode": "s = Solution()\ns.generateMatrix([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])",
        "detail": "基础模拟.59.螺旋矩阵II",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "基础模拟.LCR146.螺旋遍历二维数组",
        "description": "基础模拟.LCR146.螺旋遍历二维数组",
        "peekOfCode": "class Solution(object):\n    def spiralArray(self, array):\n        \"\"\"\n        :type array: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        if len(array)==0:\n            return []\n        m,n=len(array),len(array[0])\n        x,y=0,0",
        "detail": "基础模拟.LCR146.螺旋遍历二维数组",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "堆的使用.347.前K个高频元素",
        "description": "堆的使用.347.前K个高频元素",
        "peekOfCode": "class Solution(object):\n    def topKFrequent(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        import heapq\n        countDict=dict()\n        for num in nums:",
        "detail": "堆的使用.347.前K个高频元素",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "栈的使用.1047.删除字符串中的所有相邻重复项",
        "description": "栈的使用.1047.删除字符串中的所有相邻重复项",
        "peekOfCode": "class Solution(object):\n    def removeDuplicates(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        from collections import deque\n        stack=deque()\n        for i in range(len(s)):\n            if bool(stack) and stack[-1]==s[i]:",
        "detail": "栈的使用.1047.删除字符串中的所有相邻重复项",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "栈的使用.150. 逆波兰表达式求值",
        "description": "栈的使用.150. 逆波兰表达式求值",
        "peekOfCode": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        from collections import deque\n        calculator=[\"+\",\"-\",\"*\",\"/\"]\n        stack=deque()\n        for token in tokens:",
        "detail": "栈的使用.150. 逆波兰表达式求值",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "栈的使用.20.有效的括号",
        "description": "栈的使用.20.有效的括号",
        "peekOfCode": "class Solution(object):\n    def isValid(self, s):\n        from collections import deque\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        mapDict=dict()\n        mapDict[')'] = '('\n        mapDict['}'] = '{'",
        "detail": "栈的使用.20.有效的括号",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "滑动窗口.滑窗+单调栈.239.滑动窗口最大值",
        "description": "滑动窗口.滑窗+单调栈.239.滑动窗口最大值",
        "peekOfCode": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        from collections import deque\n        deque=deque()\n        left,right=0,0",
        "detail": "滑动窗口.滑窗+单调栈.239.滑动窗口最大值",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "滑动窗口.滑窗+单调栈.239.滑动窗口最大值",
        "description": "滑动窗口.滑窗+单调栈.239.滑动窗口最大值",
        "peekOfCode": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        from collections import deque\n        deque = deque()\n        left, right = 0, 0",
        "detail": "滑动窗口.滑窗+单调栈.239.滑动窗口最大值",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "滑动窗口.滑窗+哈希.438.找到字符串中所有字母异位词",
        "description": "滑动窗口.滑窗+哈希.438.找到字符串中所有字母异位词",
        "peekOfCode": "class Solution(object):\n    def findAnagrams(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: List[int]\n        \"\"\"\n        if len(s)<len(p):\n            return []\n        resultList=[]",
        "detail": "滑动窗口.滑窗+哈希.438.找到字符串中所有字母异位词",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "滑动窗口.滑窗+哈希.76.最小覆盖子串",
        "description": "滑动窗口.滑窗+哈希.76.最小覆盖子串",
        "peekOfCode": "class Solution(object):\n    # 2中的每一个key对应的value\n    def needShrink(self, dict1, dict2, ch):\n        contain = True\n        for key in dict2:\n            if dict1.get(key, 0) < dict2[key]:\n                contain = False\n                break\n        if contain and (ch not in dict2 or dict2[ch] <= dict1[ch]-1):\n            return True, True",
        "detail": "滑动窗口.滑窗+哈希.76.最小覆盖子串",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "滑动窗口.滑窗+哈希.904.水果成篮",
        "description": "滑动窗口.滑窗+哈希.904.水果成篮",
        "peekOfCode": "class Solution(object):\n    def totalFruit(self, fruits):\n        \"\"\"\n        :type fruits: List[int]\n        :rtype: int\n        \"\"\"\n        fruitMap=dict()\n        left,right=0,0\n        result=float('-inf')\n        while right<len(fruits):",
        "detail": "滑动窗口.滑窗+哈希.904.水果成篮",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "滑动窗口.209.长度最小的子数组",
        "description": "滑动窗口.209.长度最小的子数组",
        "peekOfCode": "class Solution(object):\n    def minSubArrayLen(self, target, nums):\n        \"\"\"\n        :type target: int\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        windowValue=0\n        left,right=0,0\n        result=float('inf')",
        "detail": "滑动窗口.209.长度最小的子数组",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "贪心.1005.K次取反后最大化的数组和",
        "description": "贪心.1005.K次取反后最大化的数组和",
        "peekOfCode": "class Solution(object):\n    def largestSumAfterKNegations(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        nums.sort()\n        sum = 0\n        for i in range(0, len(nums)):",
        "detail": "贪心.1005.K次取反后最大化的数组和",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "贪心.122.买卖股票的最佳时机II",
        "description": "贪心.122.买卖股票的最佳时机II",
        "peekOfCode": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        sum = 0\n        for i in range(0, len(prices)):\n            if i > 0 and prices[i] > prices[i - 1]:\n                sum += prices[i] - prices[i - 1]",
        "detail": "贪心.122.买卖股票的最佳时机II",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "贪心.134.加油站",
        "description": "贪心.134.加油站",
        "peekOfCode": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        minGas = float(\"inf\")\n        sumGas = 0\n        for i in range(0, len(gas)):",
        "detail": "贪心.134.加油站",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "贪心.135.分发糖果",
        "description": "贪心.135.分发糖果",
        "peekOfCode": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        candiesList = [1] * len(ratings)\n        for i in range(1, len(ratings)):\n            if ratings[i] > ratings[i - 1]:\n                candiesList[i] = candiesList[i - 1] + 1",
        "detail": "贪心.135.分发糖果",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "贪心.135.分发糖果",
        "description": "贪心.135.分发糖果",
        "peekOfCode": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        candiesList = [1] * len(ratings)\n        for i in range(1, len(ratings)):\n            if ratings[i] > ratings[i - 1]:\n                candiesList[i] = candiesList[i - 1] + 1",
        "detail": "贪心.135.分发糖果",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "贪心.376.摆动序列",
        "description": "贪心.376.摆动序列",
        "peekOfCode": "class Solution(object):\n    def wiggleMaxLength(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        isUp = None\n        result = 1\n        for i in range(1, len(nums)):\n            if isUp != False and nums[i] < nums[i - 1]:",
        "detail": "贪心.376.摆动序列",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "贪心.376.摆动序列",
        "description": "贪心.376.摆动序列",
        "peekOfCode": "class Solution(object):\n    def wiggleMaxLength(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        status = 1\n        curLength = 1\n        result = 1\n        for i in range(1, len(nums), 1):",
        "detail": "贪心.376.摆动序列",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "贪心.376.摆动序列",
        "description": "贪心.376.摆动序列",
        "peekOfCode": "class Solution(object):\n    def wiggleMaxLength(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        status = 1\n        curLength = 1\n        result = 1\n        for i in range(1, len(nums), 1):",
        "detail": "贪心.376.摆动序列",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "贪心.406.根据身高重建队列",
        "description": "贪心.406.根据身高重建队列",
        "peekOfCode": "class Solution(object):\n    def reconstructQueue(self, people):\n        \"\"\"\n        :type people: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        queue = []\n        people.sort(key=lambda x: (-x[0], x[1]))\n        for x in people:\n            queue.insert(x[1], x)",
        "detail": "贪心.406.根据身高重建队列",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "贪心.435.无重叠区间",
        "description": "贪心.435.无重叠区间",
        "peekOfCode": "class Solution(object):\n    def eraseOverlapIntervals(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        intervals.sort(key=lambda x: (x[0], [x[1]]))\n        resultList = []\n        resultCount = 0\n        for interval in intervals:",
        "detail": "贪心.435.无重叠区间",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "贪心.45.跳跃游戏II",
        "description": "贪心.45.跳跃游戏II",
        "peekOfCode": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) == 1: return 0\n        left, maxRight = 0, 0\n        step = 0\n        while True:",
        "detail": "贪心.45.跳跃游戏II",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "贪心.45.跳跃游戏II",
        "description": "贪心.45.跳跃游戏II",
        "peekOfCode": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) == 1: return 0\n        curMaxRight = nextMaxRight = step = 0\n        for i in range(len(nums)):\n            nextMaxRight = max(i + nums[i], nextMaxRight)",
        "detail": "贪心.45.跳跃游戏II",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "贪心.45.跳跃游戏II",
        "description": "贪心.45.跳跃游戏II",
        "peekOfCode": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        preMaxRight = 0\n        curMaxRight = 0\n        step = 0\n        for i in range(len(nums)):",
        "detail": "贪心.45.跳跃游戏II",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "贪心.452.用最少数量的箭引爆气球",
        "description": "贪心.452.用最少数量的箭引爆气球",
        "peekOfCode": "class Solution(object):\n    def findMinArrowShots(self, points):\n        \"\"\"\n        :type points: List[List[int]]\n        :rtype: int\n        \"\"\"\n        points.sort(key=lambda x: x[0])\n        resultList = []\n        for point in points:\n            if not resultList or resultList[-1][1] < point[0]:",
        "detail": "贪心.452.用最少数量的箭引爆气球",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "贪心.455.分发饼干",
        "description": "贪心.455.分发饼干",
        "peekOfCode": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        g.sort(key=lambda x: -x)\n        s.sort(key=lambda x: -x)\n        sum = 0",
        "detail": "贪心.455.分发饼干",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "贪心.455.分发饼干",
        "description": "贪心.455.分发饼干",
        "peekOfCode": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        g.sort(key=lambda x: -x)\n        s.sort(key=lambda x: -x)\n        i = j = sum = 0",
        "detail": "贪心.455.分发饼干",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "贪心.455.分发饼干",
        "description": "贪心.455.分发饼干",
        "peekOfCode": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        g.sort()\n        s.sort()\n        gIndex, sIndex = 0, 0",
        "detail": "贪心.455.分发饼干",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "贪心.53.最大子数组和",
        "description": "贪心.53.最大子数组和",
        "peekOfCode": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        curSum = 0\n        result = -float('inf')\n        for i in range(0, len(nums)):\n            if nums[i] >= 0:",
        "detail": "贪心.53.最大子数组和",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "贪心.53.最大子数组和",
        "description": "贪心.53.最大子数组和",
        "peekOfCode": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        curSum = 0\n        result = -float('inf')\n        for i in range(0, len(nums)):\n            curSum += nums[i]",
        "detail": "贪心.53.最大子数组和",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "贪心.55.跳跃游戏",
        "description": "贪心.55.跳跃游戏",
        "peekOfCode": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        maxRight = 0\n        for i in range(0, len(nums) - 1):\n            if i <= maxRight:\n                maxRight = max(maxRight, i + nums[i])",
        "detail": "贪心.55.跳跃游戏",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "贪心.56.合并区间",
        "description": "贪心.56.合并区间",
        "peekOfCode": "class Solution(object):\n    def merge(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        intervals.sort(key=lambda x: x[0])\n        resultList = []\n        for interval in intervals:\n            if not resultList or interval[0] > resultList[-1][1]:",
        "detail": "贪心.56.合并区间",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "贪心.738.单调递增的数字",
        "description": "贪心.738.单调递增的数字",
        "peekOfCode": "class Solution(object):\n    def monotoneIncreasingDigits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        digitList = [int(digit) for digit in str(n)]\n        resultList = [9] * len(digitList)\n        preNumber = -1\n        reverseIndex = -1",
        "detail": "贪心.738.单调递增的数字",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "贪心.738.单调递增的数字",
        "description": "贪心.738.单调递增的数字",
        "peekOfCode": "class Solution(object):\n    def monotoneIncreasingDigits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        digitList = [int(digit) for digit in str(n)]\n        lastUpdate = len(digitList)\n        for i in range(len(digitList) - 1, 0, -1):\n            if digitList[i] < digitList[i - 1]:",
        "detail": "贪心.738.单调递增的数字",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "贪心.763.划分字母区间",
        "description": "贪心.763.划分字母区间",
        "peekOfCode": "class Solution(object):\n    def partitionLabels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[int]\n        \"\"\"\n        from collections import defaultdict\n        countDict = defaultdict(int)\n        resultList = []\n        left = 0",
        "detail": "贪心.763.划分字母区间",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "贪心.763.划分字母区间",
        "description": "贪心.763.划分字母区间",
        "peekOfCode": "class Solution(object):\n    def partitionLabels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[int]\n        \"\"\"\n        intervalDict = dict()\n        for i in range(len(s)):\n            if s[i] not in intervalDict:\n                intervalDict[s[i]] = [i, i]",
        "detail": "贪心.763.划分字母区间",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "贪心.763.划分字母区间",
        "description": "贪心.763.划分字母区间",
        "peekOfCode": "class Solution(object):\n    def partitionLabels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[int]\n        \"\"\"\n        maxRightDct = dict()\n        for i in range(len(s)):\n            maxRightDct[s[i]] = i\n        left = 0",
        "detail": "贪心.763.划分字母区间",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "贪心.860.柠檬水找零",
        "description": "贪心.860.柠檬水找零",
        "peekOfCode": "class Solution(object):\n    def lemonadeChange(self, bills):\n        \"\"\"\n        :type bills: List[int]\n        :rtype: bool\n        \"\"\"\n        countDict = {5: 0, 10: 0}\n        for bill in bills:\n            if bill == 5:\n                countDict[5] += 1",
        "detail": "贪心.860.柠檬水找零",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "贪心.968.监控二叉树",
        "description": "贪心.968.监控二叉树",
        "peekOfCode": "class TreeNode(object):\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n# 每个节点有不同状态：2被覆盖、0未被覆盖、1是摄像头\nclass Solution(object):\n    def minCameraCover(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]",
        "detail": "贪心.968.监控二叉树",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "贪心.968.监控二叉树",
        "description": "贪心.968.监控二叉树",
        "peekOfCode": "class Solution(object):\n    def minCameraCover(self, root):\n        \"\"\"\n        :type root: Optional[TreeNode]\n        :rtype: int\n        \"\"\"\n        self.result = 0\n        def dfs(root):\n            if not root: return 2\n            leftStatus = dfs(root.left)",
        "detail": "贪心.968.监控二叉树",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "链表.142.环形链表II",
        "description": "链表.142.环形链表II",
        "peekOfCode": "class ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\nclass Solution(object):\n    def detectCycle(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"",
        "detail": "链表.142.环形链表II",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "链表.142.环形链表II",
        "description": "链表.142.环形链表II",
        "peekOfCode": "class Solution(object):\n    def detectCycle(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if head==None or head.next==None:\n            return None\n        slow,fast=head,head\n        # 如果是在同一个起点，那么需要移动之后再判断是否相等",
        "detail": "链表.142.环形链表II",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "链表.160.相交链表",
        "description": "链表.160.相交链表",
        "peekOfCode": "class ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n# 掌握了No.19后这道题就会有一定的思路\nclass Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        \"\"\"\n        :type head1, head1: ListNode\n        :rtype: ListNode",
        "detail": "链表.160.相交链表",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "链表.160.相交链表",
        "description": "链表.160.相交链表",
        "peekOfCode": "class Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        \"\"\"\n        :type head1, head1: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if headA==None or headB==None or headA==headB:\n            return headA\n        node1,node2=headA,headB\n        while node1.next!=None and node2.next!=None:",
        "detail": "链表.160.相交链表",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "链表.19.删除链表的倒数第 N 个结点",
        "description": "链表.19.删除链表的倒数第 N 个结点",
        "peekOfCode": "class ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :type n: int\n        :rtype: Optional[ListNode]",
        "detail": "链表.19.删除链表的倒数第 N 个结点",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "链表.19.删除链表的倒数第 N 个结点",
        "description": "链表.19.删除链表的倒数第 N 个结点",
        "peekOfCode": "class Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :type n: int\n        :rtype: Optional[ListNode]\n        \"\"\"\n        dummyHead=ListNode(0,head)\n        slow,fast=dummyHead,dummyHead\n        for i in range(n-1):",
        "detail": "链表.19.删除链表的倒数第 N 个结点",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "链表.203.移除链表元素",
        "description": "链表.203.移除链表元素",
        "peekOfCode": "class ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :type val: int\n        :rtype: Optional[ListNode]",
        "detail": "链表.203.移除链表元素",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "链表.203.移除链表元素",
        "description": "链表.203.移除链表元素",
        "peekOfCode": "class Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :type val: int\n        :rtype: Optional[ListNode]\n        \"\"\"\n        if head == None:\n            return None\n        dummyHead=ListNode(0,head)",
        "detail": "链表.203.移除链表元素",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "链表.206.反转链表",
        "description": "链表.206.反转链表",
        "peekOfCode": "class ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"",
        "detail": "链表.206.反转链表",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "链表.206.反转链表",
        "description": "链表.206.反转链表",
        "peekOfCode": "class Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        if head==None or head.next==None:\n            return head\n        dummyHead=ListNode(0,head)\n        pre,cur=dummyHead,dummyHead.next",
        "detail": "链表.206.反转链表",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "链表.24.两两交换链表中的节点",
        "description": "链表.24.两两交换链表中的节点",
        "peekOfCode": "class ListNode(object):\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"",
        "detail": "链表.24.两两交换链表中的节点",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "链表.24.两两交换链表中的节点",
        "description": "链表.24.两两交换链表中的节点",
        "peekOfCode": "class Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        if head==None or head.next==None:\n            return head\n        dummyHead=ListNode(0,head)\n        pre,cur,after=dummyHead,dummyHead.next,dummyHead.next.next",
        "detail": "链表.24.两两交换链表中的节点",
        "documentation": {}
    }
]