## 🧭 共同目标：最短路径问题（Shortest Path Problem）

给定一个**加权有向图** $G=(V,E)$，边 $(u,v)$ 的权值为 $w(u,v)$，希望找到：

* **单源最短路径**：从一个起点 $s$ 到所有其他顶点的最短路径；
* **多源最短路径**：任意两点之间的最短路径。

---

## 三个算法的区别

| 算法                 | 问题类型         | 是否允许负权边  | 是否能检测负环 | 复杂度                   | 思想             |
| ------------------ | ------------ | -------- | ------- | --------------------- | -------------- |
| **Dijkstra**       | 单源最短路径       | ❌ 不允许负权边 | ❌ 不检测负环 | $O((V+E)\log V)$（堆优化） | 贪心             |
| **Bellman-Ford**   | 单源最短路径       | ✅ 允许负权边  | ✅ 能检测负环 | $O(VE)$               | 动态规划（松弛操作）     |
| **Floyd-Warshall** | 多源最短路径（任意两点） | ✅ 允许负权边  | ✅ 能检测负环 | $O(V^3)$              | 动态规划（逐点加入中间节点） |

---

## 📘 三、算法直觉对比

### 1. Dijkstra 算法（贪心思想）

* **用途**：从起点 $s$ 到所有节点的最短距离（不含负权边）。
* **思想**：
  每次从未确定的节点中选出**距离最小**的节点，确定其最短路径，然后更新相邻节点。
* **例子**：最常见于地图导航、网络路由。
* **核心逻辑**：

  ```text
  dist[s] = 0
  while (还有未访问节点):
      选出距离最小的节点 u
      对于 u 的每条边 (u,v):
          if dist[u] + w(u,v) < dist[v]:
              dist[v] = dist[u] + w(u,v)
  ```

---

### 2. Bellman-Ford 算法（动态规划 + 松弛）

* **用途**：解决带负权边的单源最短路径问题。
* **思想**：
  连续进行“松弛”操作，每次允许路径经过的边数增加一条。
* **核心逻辑**：
  重复 $V-1$ 轮，每轮遍历所有边 $(u,v)$：

  ```text
  if dist[u] + w(u,v) < dist[v]:
      dist[v] = dist[u] + w(u,v)
  ```
* **额外能力**：再多做一轮，如果还能更新，说明存在**负环**。

---

### 3. Floyd-Warshall 算法（多源动态规划）

* **用途**：计算所有点对之间的最短路径。
* **思想**：
  逐步尝试将第 $k$ 个点作为“中间节点”，更新所有 $(i,j)$ 的最短距离。
* **核心逻辑**：

  ```text
  for k in V:
      for i in V:
          for j in V:
              if dist[i][k] + dist[k][j] < dist[i][j]:
                  dist[i][j] = dist[i][k] + dist[k][j]
  ```
* **特点**：结构简单、实现容易，但复杂度高 $O(V^3)$，适合节点较少的图（如 100~500 个点以内）。

---

## 总结思维导图

```
最短路径问题
├── 单源最短路径
│   ├── Dijkstra（无负权，贪心）
│   └── Bellman-Ford（可负权，检测负环）
└── 多源最短路径
    └── Floyd-Warshall（可负权，O(V^3)）
```

---

## 总结一句话：

> * **Dijkstra**：快速，但不能有负权边。
> * **Bellman-Ford**：慢一点，但能处理负权与负环。
> * **Floyd-Warshall**：最通用，任意两点最短路径，但代价是 $O(V^3)$ 的时间。