# 例如当n = 4时，当1为根节点，其左边就没有节点，右边有3个节点，故当前二叉搜索树有dp[0] * dp[3]种
# 当2为根节点，其左边就有1个节点，右边有2个节点，故当前二叉搜索树有dp[1] * dp[2]种
# 当3为根节点，其左边就有2个节点，右边有1个节点，故当前二叉搜索树有dp[2] * dp[1]种
# 当4为根节点，其左边就有3个节点，右边有0个节点，故当前二叉搜索树有dp[3] * dp[0]种
# 最后我们就可以得到n =4时，搜索二叉树的种类共有dp[0] * dp[3] + dp[1] * dp[2] + dp[2] * dp[1] + dp[3] * dp[0]种
# 由于这些都依赖于前面的结果，此时就可以使用动态规划来完成
# 其中一个关键的点在于 比如针对“当1为根节点，其左边就没有节点，右边有3个节点” 右边的3个节点（2,3,4）的组合数量其实和（1,2,3）是一样的
class Solution(object):

    def numTrees(self, n):
        """
        :type n: int
        :rtype: int
        """
        if n == 1: return 1
        dp = [0] * (n + 1)
        dp[0] = 1
        dp[1] = 1
        for i in range(2, n + 1):
            for j in range(0, i):
                dp[i] += dp[j] * dp[i - 1 - j]
            print(dp[i])
        return dp[n]


Solution().numTrees(3)
